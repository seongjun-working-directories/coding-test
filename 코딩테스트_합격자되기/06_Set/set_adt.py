'''
1. 상호배타적 집합(=교집합이 없는 집합)
그래프 알고리즘에서 사이클을 확인하는 일이 많은데, 이때 상호배타적 집합 개념을 활용함

2. 집합의 표현
집합은 배열을 활용한 트리로 구현됨

각 집합에는 대표 원소(집합의 원소 중 집합을 대표하는 역할을 하는 원소)가 있어야 함
- 개념적으로 집합의 대표 원소와 트리의 루트 노드는 같음

집합을 배열로 표현한다는 것은 하나의 배열로 상호 배타적 관계를 가지는 집합을 모두 표현함을 의미
- 배열의 인덱스는 자신을, 배열값은 부모노드를 의미함
- 단, 루트노드일 경우, 배열의 인덱스와 배열값이 일치함
- 상호 배타적인 두 집합에 대해, 하나의 배열에서 트리형태로 나타낼 수 있음
  (집합의 개수는 루트노드의 개수로 파악 가능)

집합을 배열로 구현
- 1, 2, 3, 4, 5, 8, 9 로 두 개의 집합을 만든다고 하면 배열의 초기 상태는 다음과 같음
    1  2  3  4  5  6  7  8  9
  ----------------------------
  | 1| 2| 3| 4| 5|-1|-1| 8| 9|
  ----------------------------
  즉, 초기 각 노드는 자기 자신을 루트 노드로 하고, 집합에 없는 인덱스의 값은 -1로 함
- 그리고 각 노드의 연결관계가 주어지게 되면 다음과 같은 형태로 완성됨
    1  2  3  4  5  6  7  8  9
  ----------------------------
  | 1| 1| 2| 4| 1|-1|-1| 4| 3|
  ----------------------------

3. 유니온-파인드 알고리즘
집합 알고리즘에 주로 쓰이는 연산은 합치기(Union)와 탐색(Find)임

3-(1). 파인드 연산
특정 노드의 루트노드가 무엇인지 탐색하는 방법
- 특정 노드가 같은 집합에 있는지 확인할 때 사용
  (즉, A와 B라는 노드가 있을 때 두 노드의 루트노드가 같다면, 같은 집합에 속한 것)
- 과정은 다음과 같음
  - 현재 노드의 부모 노드를 확인
  - 부모 노드를 확인하다가 부모 노드가 루트노드이면 찾기 연산을 종료
- 탐색 연산은 재귀로 구현됨 -> 시간복잡도는 최악의 경우 O(N)에 해당

파인드 연산의 연산 비용 문제, 경로 압축으로 해결 가능
- 경로 압축은 트리의 깊이 압축을 통해 실현 가능
  1             1
  ^         ^   ^   ^
  |         |   |   |
  2         2   3   4
  ^
  |
  3

3-(2). 합치기 연산
두 집합을 하나로 합치는 연산
- 즉, 두 집합의 루트노드를 같게 만드는 것
- 이때, 루트노드는 두 집합의 루트노드 중 하나가 됨

과정은 다음과 같음
- 두 집합에서 찾기 연산으로 루트노드를 찾음
- 찾은 두 루트노드의 값을 비교함
- 두 집합을 합침(이때, 루트 노드는 두 집합 중 어떤 루트노드로 해도 상관 없음)
    1       2                1
   ^ ^     ^ ^            ^  ^  ^
   | |     | |            |  |  |
   3 5     7 9            3  5  2
                               ^ ^
                               | |
                               7 9

합치기 연산의 연산 비용 문제, 랭크로 해결 가능
- 랭크: 현재 노드를 기준으로 하였을 때 가장 깊은 노드까지의 경로 길이를 의미
  [2]      1
  [1]    2   3  [0]
  [0]   4

랭크를 기반으로 합치기 연산을 하는 방법
- 두 노드의 루트노드를 구함
- 구한 루트노드의 랭크를 비교함
  - 랭크값이 다르면 랭크값이 큰 루트노드를 기준으로 삼음
    (즉, 랭크가 더 큰 루트 노드를 랭크가 작은 루트노드의 부모노드로 설정함)
    (이 경우, 트리의 깊이는 더 깊어지지 않으므로 랭크 값이 변하지 않음)
  - 랭크값이 같으면 루트노드를 아무거나 선택해서 바꾸고 최종 루트노드의 랭크에 1을 더함
'''
class DisjointSet:
    def __init__(self, size):
        # 부모 배열 초기화
        self.parent = list(range(size))
        # 랭크 배열 초기화
        self.rank = [0] * size

    def find(self, node):
        # 경로 압축
        if self.parent[node] != node:
            self.parent[node] = self.find(self.parent[node])
        return self.parent[node]

    def union(self, node1, node2):
        root1 = self.find(node1)
        root2 = self.find(node2)

        if root1 != root2:
            # 랭크에 따라 트리 합치기
            if self.rank[root1] > self.rank[root2]:
                self.parent[root2] = root1
            elif self.rank[root1] < self.rank[root2]:
                self.parent[root1] = root2
            else:
                self.parent[root2] = root1
                self.rank[root1] += 1

    def connected(self, node1, node2):
        # 두 노드가 같은 집합에 속하는지 확인
        return self.find(node1) == self.find(node2)

# 예제 사용
if __name__ == "__main__":
    ds = DisjointSet(10)  # 0부터 9까지의 노드로 구성된 집합 생성

    ds.union(1, 2)
    ds.union(2, 3)
    ds.union(4, 5)
    ds.union(5, 6)
    ds.union(1, 4)

    print(ds.connected(1, 3))  # True, 1과 3은 같은 집합
    print(ds.connected(1, 5))  # True, 1과 5는 같은 집합
    print(ds.connected(7, 8))  # False, 7과 8은 다른 집합
